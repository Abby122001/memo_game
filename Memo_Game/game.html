<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Memory Card Game</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }

    body {
      background-color: #50733f; /* Dark green background */
      text-align: center;
      margin: 0;
      min-height: 100vh;
      padding: 30px;
      color: #5d2a00; /* Dark brown text */
      position: relative;
      font-size: 16px;
      line-height: 1.6;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .back-button {
      position: absolute;
      top: 20px;
      left: 20px;
      background: linear-gradient(145deg, #7a3b0d, #5d2a00);
      border: none;
      color: #f6c440;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s;
      box-shadow: 2px 2px 4px rgba(0,0,0,0.2);
    }

    .back-button:hover {
      background: rgba(255,255,255,0.3);
      transform: scale(1.1);
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 700;
      margin: 0 0 0.5em;
      color: #f6c440;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      letter-spacing: 1px;
      background: linear-gradient(145deg, #7a3b0d, #5d2a00);
      display: inline-block;
      padding: 10px 30px;
      border-radius: 30px;
      margin-bottom: 30px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    }

    .subtitle {
      font-size: 1.1rem;
      font-weight: 400;
      margin-bottom: 2.5rem;
      opacity: 0.9;
      letter-spacing: 0.3px;
    }

    .level-container {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
      justify-items: center;
      max-width: 400px;
      margin: 0 auto;
      background: linear-gradient(145deg, #ffd4a3, #dfb18f);
      padding: 30px;
      border-radius: 20px;
      box-shadow: 
        inset 4px 4px 16px #b49067,
        inset -4px -4px 16px #ffd9b9,
        6px 6px 10px rgba(0,0,0,0.3);
    }

    .level-btn {
      background: linear-gradient(145deg, #ffd4a3, #dfb18f);
      border: 2px solid #b49067;
      color: #5d2a00;
      font-size: 2em;
      border-radius: 15px;
      width: 150px;
      height: 100px;
      cursor: pointer;
      box-shadow: 
        inset 2px 2px 8px #b49067,
        inset -2px -2px 8px #ffd9b9,
        4px 4px 10px rgba(0,0,0,0.2);
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      font-weight: bold;
    }

    .level-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: 0.5s;
    }

    .level-btn:hover::before {
      left: 100%;
    }

    .level-btn:hover {
      transform: translateY(-5px) scale(1.03);
      box-shadow: 0 10px 20px rgba(0,0,0,0.3);
    }

    .level-btn:active {
      transform: translateY(2px) scale(0.98);
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    .level-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Poppins', sans-serif;
    }
    
    .level-btn span {
      display: block;
      font-size: 1.75rem;
      font-weight: 600;
      margin-bottom: 0.25rem;
      line-height: 1;
    }
    
    .level-btn small {
      display: block;
      font-size: 0.75rem;
      font-weight: 400;
      opacity: 0.9;
      letter-spacing: 0.5px;
    }

    .loading {
      display: none;
      margin-top: 20px;
      color: white;
      font-size: 1.1em;
    }

    .loading i {
      margin-right: 10px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Game Board Styles */
    .game-container {
      display: none;
      flex-direction: column;
      align-items: center;
      margin-top: 20px;
    }

    .game-header {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 600px;
      margin-bottom: 20px;
    }

    .stats {
      background: rgba(255, 255, 255, 0.1);
      padding: 0.75rem 1.5rem;
      border-radius: 20px;
      font-size: 1rem;
      font-weight: 500;
      letter-spacing: 0.3px;
    }

    .game-board {
      display: grid;
      grid-gap: 10px;
      background: linear-gradient(145deg, #ffd4a3, #dfb18f);
      padding: 20px;
      border-radius: 20px;
      max-width: 100%;
      margin: 0 auto;
      box-shadow: 
        inset 4px 4px 16px #b49067,
        inset -4px -4px 16px #ffd9b9,
        6px 6px 10px rgba(0,0,0,0.3);
    }

    .card {
      width: 80px;
      height: 80px;
      perspective: 1000px;
      cursor: pointer;
      background: transparent;
      border: none;
      outline: none;
    }

    .card-inner {
      position: relative;
      width: 100%;
      height: 100%;
      text-align: center;
      transition: transform 0.6s;
      transform-style: preserve-3d;
    }

    .card.flipped .card-inner {
      transform: rotateY(180deg);
    }

    .card-front,
    .card-back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      border-radius: 15px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 
        inset 2px 2px 5px rgba(0,0,0,0.1),
        2px 2px 5px rgba(0,0,0,0.2);
      transition: all 0.3s ease;
    }

    .card-front {
      background: linear-gradient(145deg, #7a3b0d, #5d2a00);
      transform: rotateY(180deg);
      color: #f6c440;
    }

    .card-back {
      background: linear-gradient(145deg, #ffd4a3, #dfb18f);
      color: #5d2a00;
      font-size: 1.75rem;
      font-weight: 600;
      border: 2px solid #b49067;
    }

    .card.matched {
      opacity: 0.6;
      cursor: default;
      filter: saturate(0.8);
    }

    .win-message {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(145deg, #ffd4a3, #dfb18f);
      padding: 2rem;
      border-radius: 20px;
      text-align: center;
      box-shadow: 
        0 10px 30px rgba(0, 0, 0, 0.3),
        inset 2px 2px 10px rgba(255,255,255,0.5);
      z-index: 1000;
      color: #5d2a00;
      width: 90%;
      max-width: 400px;
      border: 2px solid #b49067;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1rem;
      margin: 1.5rem 0;
      text-align: left;
      background: rgba(255, 255, 255, 0.9);
      padding: 1.2rem;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    
    .stats-grid div {
      font-size: 1.1rem;
      font-weight: 500;
    }
    
    .button-group {
      display: flex;
      gap: 1rem;
      margin-top: 1.5rem;
      justify-content: center;
    }
    
    .next-level-btn {
      background: linear-gradient(145deg, #7a3b0d, #5d2a00);
      color: #f6c440;
      border: none;
      padding: 0.75rem 2rem;
      border-radius: 30px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 
        0 4px 15px rgba(0, 0, 0, 0.2),
        inset 1px 1px 0 rgba(255,255,255,0.2);
    }
    
    .next-level-btn:hover {
      background: linear-gradient(145deg, #8a4b1a, #6b3200);
      transform: translateY(-2px);
      box-shadow: 
        0 6px 20px rgba(0, 0, 0, 0.25),
        inset 1px 1px 0 rgba(255,255,255,0.2);
    }
    
    .level-btn {
      position: relative;
    }
    
    .level-btn .lock-icon {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 1rem;
      opacity: 0.7;
    }
    
    .level-btn .best-score {
      position: absolute;
      bottom: 10px;
      left: 0;
      right: 0;
      font-size: 0.7rem;
      opacity: 0.9;
    }

    .win-message h2 {
      margin: 0 0 1rem;
      color: #5d2a00;
      font-size: 1.75rem;
      font-weight: 600;
      text-shadow: 1px 1px 0 rgba(255,255,255,0.5);
    }

    .win-message p {
      font-size: 1.1rem;
      margin-bottom: 1.5rem;
      color: #333;
    }

    .new-game-btn {
      background: #50733f;
      color: white;
      border: none;
      padding: 0.75rem 2rem;
      border-radius: 30px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    .new-game-btn:hover {
      background: #5d2a00;
      transform: translateY(-2px);
    }
  </style>
</head>
<body>
  <button class="back-button" id="backButton">
    <i class="fas fa-arrow-left"></i>
  </button>

  <div id="levelSelection">
    <h1>Memory Card Game <span id="levelDisplay"></span></h1>
    <p class="subtitle">Match all pairs to win!</p>
    
    <div class="level-container">
      <button class="level-btn" data-level="3x2">
        <span>3x2</span>
        <small>Easy</small>
      </button>
      <button class="level-btn" data-level="4x3">
        <span>4x3</span>
        <small>Medium</small>
      </button>
      <button class="level-btn" data-level="5x4">
        <span>5x4</span>
        <small>Hard</small>
      </button>
      <button class="level-btn" data-level="6x5">
        <span>6x5</span>
        <small>Expert</small>
      </button>
    </div>
  </div>

  <div class="game-container" id="gameContainer">
    <div class="game-header">
      <div class="stats">‚è±Ô∏è <span id="timer">0:00</span></div>
      <div class="stats">Moves: <span id="moves">0</span></div>
      <div class="stats">Matches: <span id="matches">0</span>/<span id="totalPairs">0</span></div>
      <div class="stats">Stars: <span id="stars">0</span>‚≠ê</div>
    </div>
    <div class="game-board" id="gameBoard"></div>
  </div>

  <div class="win-message" id="winMessage">
    <h2>üéâ Level Complete! üéâ</h2>
    <div class="stats-grid">
      <div>Moves: <span id="finalMoves">0</span></div>
      <div>Time: <span id="finalTime">0:00</span></div>
      <div>Stars: <span id="starsEarned">0</span></div>
    </div>
    <div class="button-group">
      <button class="new-game-btn" id="newGameBtn">Play Again</button>
      <button class="next-level-btn" id="nextLevelBtn">Next Level</button>
    </div>
  </div>

  <div class="loading" id="loadingIndicator">
    <i class="fas fa-spinner"></i> Preparing your game...
  </div>

  <script>
    // Game state
    let gameState = {
      cards: [],
      flippedCards: [],
      matchedPairs: 0,
      moves: 0,
      canFlip: true,
      level: null,
      category: 'animals',
      timer: 0,
      timerInterval: null,
      stars: 0,
      gameMode: 'quick' // 'quick' or 'quest'
    };
    
    // Level progression data
    const levelData = {
      '3x2': { next: '4x3', timeTargets: [30, 60] }, // Under 30s = 3 stars, 30-60s = 2 stars, 60+ = 1 star
      '4x3': { next: '5x4', timeTargets: [45, 90] },
      '5x4': { next: '6x5', timeTargets: [60, 120] },
      '6x5': { next: null, timeTargets: [90, 180] }
    };
    
    // Game progress in local storage
    let gameProgress = JSON.parse(localStorage.getItem('memoryGameProgress')) || {
      quick: { unlocked: '3x2', scores: {} },
      quest: { unlocked: null, scores: {} }
    };

    // Card categories and their corresponding icons
    const cardCategories = {
      animals: ['üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üê®', 'üêØ', 'ü¶Å', 'üêÆ', 'üê∑', 'üê∏', 'üêµ', 'üêî'],
      icons: ['‚≠ê', '‚ù§Ô∏è', 'üéØ', 'üé®', '‚öΩ', 'üéÆ', 'üé≤', 'üéØ', 'üé≥', 'üé≠', 'üé™', 'üé°', 'üé¢', 'üé†', 'üèÜ', 'üèÖ'],
      fruits: ['üçé', 'üçê', 'üçä', 'üçã', 'üçå', 'üçâ', 'üçá', 'üçì', 'üçà', 'üçí', 'üçë', 'ü•≠', 'üçç', 'ü•ù', 'üçÖ', 'ü•ë'],
      vehicles: ['üöó', 'üöï', 'üöô', 'üöå', 'üèéÔ∏è', 'üöì', 'üöë', 'üöí', 'üöê', 'üöö', 'üöõ', 'üöú', 'üèçÔ∏è', 'üõµ', '‚úàÔ∏è', 'üõ©Ô∏è']
    };

    // DOM Elements
    const gameBoard = document.getElementById('gameBoard');
    const gameContainer = document.getElementById('gameContainer');
    const levelSelection = document.getElementById('levelSelection');
    const movesDisplay = document.getElementById('moves');
    const matchesDisplay = document.getElementById('matches');
    const totalPairsDisplay = document.getElementById('totalPairs');
    const timerDisplay = document.getElementById('timer');
    const starsDisplay = document.getElementById('stars');
    const winMessage = document.getElementById('winMessage');
    const finalMoves = document.getElementById('finalMoves');
    const finalTime = document.getElementById('finalTime');
    const starsEarned = document.getElementById('starsEarned');
    const newGameBtn = document.getElementById('newGameBtn');
    const nextLevelBtn = document.getElementById('nextLevelBtn');
    const backButton = document.getElementById('backButton');
    const loadingIndicator = document.getElementById('loadingIndicator');
    
    // Update level buttons based on unlocked levels
    function updateLevelButtons() {
      document.querySelectorAll('.level-btn').forEach(btn => {
        const level = btn.dataset.level;
        const isUnlocked = isLevelUnlocked(level);
        btn.disabled = !isUnlocked;
        btn.title = isUnlocked ? '' : 'Complete previous levels to unlock';
        
        // Show lock icon for locked levels
        const lockIcon = btn.querySelector('.lock-icon') || document.createElement('i');
        if (!isUnlocked) {
          lockIcon.className = 'fas fa-lock lock-icon';
          if (!btn.contains(lockIcon)) {
            btn.insertBefore(lockIcon, btn.firstChild);
          }
        } else if (btn.contains(lockIcon)) {
          btn.removeChild(lockIcon);
        }
        
        // Show best score if available
        const bestScore = getBestScore(level);
        const scoreDisplay = btn.querySelector('.best-score') || document.createElement('div');
        if (bestScore) {
          scoreDisplay.className = 'best-score';
          scoreDisplay.innerHTML = `‚≠ê${bestScore.stars} ${formatTime(bestScore.time)}`;
          if (!btn.contains(scoreDisplay)) {
            btn.appendChild(scoreDisplay);
          }
        } else if (btn.contains(scoreDisplay)) {
          btn.removeChild(scoreDisplay);
        }
      });
    }
    
    function isLevelUnlocked(level) {
      const currentMode = gameState.gameMode;
      const unlockedLevel = gameProgress[currentMode].unlocked;
      
      if (!unlockedLevel) return level === '3x2'; // First level is always unlocked
      
      const levels = ['3x2', '4x3', '5x4', '6x5'];
      return levels.indexOf(level) <= levels.indexOf(unlockedLevel);
    }
    
    function getBestScore(level) {
      return gameProgress[gameState.gameMode].scores[level];
    }
    
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
    }

    // Load saved progress
    function loadProgress() {
      const savedProgress = localStorage.getItem('memoryGameProgress');
      if (savedProgress) {
        return JSON.parse(savedProgress);
      }
      // Return default levels if no saved progress
      return Array(28).fill().map((_, i) => ({
        number: i + 1,
        stars: 0,
        required: Math.min(Math.floor(i / 4), 6),
        completed: false,
        locked: i > 0
      }));
    }

    // Save progress to localStorage
    function saveProgress(levelNumber, stars) {
      const progress = loadProgress();
      const levelIndex = levelNumber - 1;
      
      if (levelIndex >= 0 && levelIndex < progress.length) {
        // Update stars if better than previous
        if (stars > progress[levelIndex].stars) {
          progress[levelIndex].stars = stars;
        }
        
        // Mark level as completed
        progress[levelIndex].completed = true;
        
        // Unlock next level if exists
        if (levelIndex + 1 < progress.length) {
          progress[levelIndex + 1].locked = false;
        }
        
        localStorage.setItem('memoryGameProgress', JSON.stringify(progress));
      }
    }

    // Initialize the game
    document.addEventListener('DOMContentLoaded', () => {
      // Get level from URL or use default
      const urlParams = new URLSearchParams(window.location.search);
      const level = parseInt(urlParams.get('level')) || 1;
      
      // Set the current level
      currentLevel = level;
      
      // Update level display
      const levelDisplay = document.getElementById('levelDisplay');
      if (levelDisplay) {
        levelDisplay.textContent = `Level ${level}`;
      }
      gameState.category = urlParams.get('category') || 'animals';
      gameState.gameMode = urlParams.get('mode') || 'quick';
      
      // Set up event listeners
      document.querySelectorAll('.level-btn').forEach(btn => {
        btn.addEventListener('click', () => startGame(btn.dataset.level));
      });
      
      newGameBtn.addEventListener('click', resetGame);
      nextLevelBtn.addEventListener('click', startNextLevel);
      backButton.addEventListener('click', () => {
        window.location.href = gameState.gameMode === 'quest' ? 'quest.html' : 'quick_game.html';
      });
      
      // Update UI based on unlocked levels
      updateLevelButtons();
    });
    
    // Timer functions
    function startTimer() {
      gameState.timer = 0;
      updateTimerDisplay();
      gameState.timerInterval = setInterval(() => {
        gameState.timer++;
        updateTimerDisplay();
      }, 1000);
    }
    
    function stopTimer() {
      if (gameState.timerInterval) {
        clearInterval(gameState.timerInterval);
        gameState.timerInterval = null;
      }
    }
    
    function updateTimerDisplay() {
      if (timerDisplay) {
        timerDisplay.textContent = formatTime(gameState.timer);
      }
    }
    
    function calculateStars(time, level) {
      // Calculate stars based on time and level difficulty
      // More difficult levels have more lenient time requirements
      const difficultyFactor = Math.ceil(level / 7); // 1-4
      const timeLimits = [
        30 + (difficultyFactor * 10),  // 3 stars
        60 + (difficultyFactor * 20),  // 2 stars
        120 + (difficultyFactor * 30)  // 1 star
      ];
      
      if (time <= timeLimits[0]) return 3;
      if (time <= timeLimits[1]) return 2;
      if (time <= timeLimits[2]) return 1;
      return 0; // No stars if took too long
    }

    function startGame(level) {
      if (!isLevelUnlocked(level)) return;
      
      gameState.level = level;
      const [rows, cols] = level.split('x').map(Number);
      const totalPairs = (rows * cols) / 2;
      
      // Show loading
      loadingIndicator.style.display = 'block';
      levelSelection.style.display = 'none';
      winMessage.style.display = 'none';
      
      // Initialize game state
      gameState.matchedPairs = 0;
      gameState.moves = 0;
      gameState.flippedCards = [];
      
      // Update UI
      movesDisplay.textContent = '0';
      matchesDisplay.textContent = '0';
      totalPairsDisplay.textContent = totalPairs;
      
      // Create cards after a short delay to allow for loading animation
      setTimeout(() => {
        createCards(rows, cols);
        loadingIndicator.style.display = 'none';
        gameContainer.style.display = 'flex';
        startTimer();
      }, 500);
    }
    
    function startNextLevel() {
      const nextLevel = levelData[gameState.level]?.next;
      if (nextLevel) {
        startGame(nextLevel);
      } else {
        // No more levels, go back to level selection
        resetGame();
      }
    }

    function createCards(rows, cols) {
      gameBoard.innerHTML = '';
      gameBoard.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      
      const totalPairs = (rows * cols) / 2;
      const icons = getRandomIcons(gameState.category, totalPairs);
      
      // Create pairs of cards
      const cards = [];
      icons.forEach(icon => {
        cards.push(createCard(icon));
        cards.push(createCard(icon));
      });
      
      // Shuffle cards
      gameState.cards = shuffleArray([...cards]);
      
      // Add cards to board
      gameState.cards.forEach((card, index) => {
        card.dataset.index = index;
        gameBoard.appendChild(card);
      });
    }

    function createCard(icon) {
      const card = document.createElement('div');
      card.className = 'card';
      
      const cardInner = document.createElement('div');
      cardInner.className = 'card-inner';
      
      const cardFront = document.createElement('div');
      cardFront.className = 'card-front';
      cardFront.textContent = icon;
      
      const cardBack = document.createElement('div');
      cardBack.className = 'card-back';
      cardBack.textContent = '?';
      
      cardInner.appendChild(cardFront);
      cardInner.appendChild(cardBack);
      card.appendChild(cardInner);
      
      card.addEventListener('click', () => flipCard(card));
      
      return card;
    }

    function flipCard(card) {
      // Don't allow flipping if:
      // - Already flipping cards
      // - Card is already flipped or matched
      // - Already have 2 cards flipped
      if (!gameState.canFlip || 
          card.classList.contains('flipped') || 
          card.classList.contains('matched') ||
          gameState.flippedCards.length >= 2) {
        return;
      }
      
      // Flip the card
      card.classList.add('flipped');
      gameState.flippedCards.push(card);
      
      // Check for match when 2 cards are flipped
      if (gameState.flippedCards.length === 2) {
        gameState.moves++;
        movesDisplay.textContent = gameState.moves;
        
        const [firstCard, secondCard] = gameState.flippedCards;
        
        if (firstCard.querySelector('.card-front').textContent === 
            secondCard.querySelector('.card-front').textContent) {
          // Match found
          firstCard.classList.add('matched');
          secondCard.classList.add('matched');
          gameState.flippedCards = [];
          gameState.matchedPairs++;
          matchesDisplay.textContent = gameState.matchedPairs;
          
          // Check for win
          if (gameState.matchedPairs === parseInt(totalPairsDisplay.textContent)) {
            setTimeout(showWinMessage, 500);
          }
        } else {
          // No match, flip cards back after delay
          gameState.canFlip = false;
          setTimeout(() => {
            firstCard.classList.remove('flipped');
            secondCard.classList.remove('flipped');
            gameState.flippedCards = [];
            gameState.canFlip = true;
          }, 1000);
        }
      }
    }

    function showWinMessage() {
      // Stop the timer
      stopTimer();
      
      // Calculate stars based on time and moves
      const stars = calculateStars(gameState.timer, gameState.level);
      gameState.stars = stars;
      
      // Update best score if this is better
      updateBestScore(stars);
      
      // Update UI
      finalMoves.textContent = gameState.moves;
      finalTime.textContent = formatTime(gameState.timer);
      starsEarned.textContent = '‚≠ê'.repeat(stars);
      
      // Show appropriate buttons
      const nextLevel = levelData[gameState.level]?.next;
      nextLevelBtn.style.display = nextLevel ? 'inline-block' : 'none';
      
      // Show win message
      winMessage.style.display = 'block';
      
      // Unlock next level if applicable
      if (nextLevel) {
        const currentMode = gameState.gameMode;
        const nextLevelIndex = ['3x2', '4x3', '5x4', '6x5'].indexOf(nextLevel);
        const currentUnlockedIndex = ['3x2', '4x3', '5x4', '6x5'].indexOf(gameProgress[currentMode].unlocked || '3x2');
        
        if (nextLevelIndex > currentUnlockedIndex) {
          gameProgress[currentMode].unlocked = nextLevel;
          localStorage.setItem('memoryGameProgress', JSON.stringify(gameProgress));
        }
      }
    }
    
    function updateBestScore(stars) {
      const currentMode = gameState.gameMode;
      const level = gameState.level;
      const currentBest = gameProgress[currentMode].scores[level];
      
      if (!currentBest || 
          stars > currentBest.stars || 
          (stars === currentBest.stars && gameState.timer < currentBest.time)) {
        gameProgress[currentMode].scores[level] = {
          stars: stars,
          time: gameState.timer,
          moves: gameState.moves,
          timestamp: new Date().toISOString()
        };
        localStorage.setItem('memoryGameProgress', JSON.stringify(gameProgress));
      }
    }

    function resetGame() {
      // Clear game state
      stopTimer();
      gameState.matchedPairs = 0;
      gameState.moves = 0;
      gameState.flippedCards = [];
      
      // Reset UI
      winMessage.style.display = 'none';
      gameContainer.style.display = 'none';
      levelSelection.style.display = 'block';
      
      // Update level buttons to reflect any new unlocks
      updateLevelButtons();
    }

    function getRandomIcons(category, count) {
      const icons = [...cardCategories[category]];
      const selectedIcons = [];
      
      while (selectedIcons.length < count && icons.length > 0) {
        const randomIndex = Math.floor(Math.random() * icons.length);
        selectedIcons.push(icons.splice(randomIndex, 1)[0]);
      }
      
      return selectedIcons;
    }

    function shuffleArray(array) {
      const newArray = [...array];
      for (let i = newArray.length - 1; i > 0; i-- ) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
      }
      return newArray;
    }
  </script>

</body>
</html>
